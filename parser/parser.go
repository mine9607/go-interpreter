package parser

import (
	"fmt"
	"monkey/ast"
	"monkey/lexer"
	"monkey/token"
)

// Note curToken and peekToken act like the lexer pointers "position" and "readPosition" but instead of pointing to input chars they point to the token struct generated by those chars
type Parser struct {
	l         *lexer.Lexer // pointer to an instance of the lexer
	curToken  token.Token  // current Token ~ lexer "position"
	peekToken token.Token  // peek Token ~ lexer "readPosition"
	errors    []string
}

// func to initialize an instance of a Parser - accepts a lexer instance and returns a pointer to a parser instance
// the function accepts a lexer and sets the Parer's lexer property = the lexer
// p.nextToken() is called to advance the lexer and tokens 2 chars from their initial position
// so that they line up with the first and second chars of the input and first and second tokens from the lexer respectively
func New(l *lexer.Lexer) *Parser {
	p := &Parser{
		l:      l,
		errors: []string{},
	}

	// read two tokens, so curToken and peekToken are both set
	p.nextToken()
	p.nextToken()

	return p
}

func (p *Parser) Errors() []string {
	return p.errors
}

func (p *Parser) peekError(t token.TokenType) {
	msg := fmt.Sprintf("expected next token to be %s, got %s instead", t, p.peekToken.Type)
	p.errors = append(p.errors, msg)
}

// parser helper function to advance the current and peek tokens
func (p *Parser) nextToken() {
	p.curToken = p.peekToken
	p.peekToken = p.l.NextToken()
}

// helper functions below
func (p *Parser) curTokenIs(t token.TokenType) bool {
	return p.curToken.Type == t
}

func (p *Parser) peekTokenIs(t token.TokenType) bool {
	return p.peekToken.Type == t
}

// ** This is an ASSERTION FUNCTION common to most parsers **
// Its purpose is to enforce the correctness of the order of tokens by checking the type of the next token
// It looks at the next token and only if it is the expected next token is p.nextToken does it call nextToken
func (p *Parser) expectPeek(t token.TokenType) bool {
	if p.peekTokenIs(t) {
		p.nextToken()
		return true
	} else {
		p.peekError(t)
		return false
	}
}

// THIS IS THE PARSING LOGIC FOR THE PROGRAM
func (p *Parser) ParseProgram() *ast.Program {
	program := &ast.Program{}
	program.Statements = []ast.Statement{}

	for !p.curTokenIs(token.EOF) {
		stmt := p.parseStatement()
		if stmt != nil {
			program.Statements = append(program.Statements, stmt)
		}
		p.nextToken()
	}
	return program
}

func (p *Parser) parseStatement() ast.Statement {
	switch p.curToken.Type {
	case token.LET:
		return p.parseLetStatement()
	default:
		return nil
	}
}

func (p *Parser) parseLetStatement() *ast.LetStatement {
	stmt := &ast.LetStatement{Token: p.curToken}

	if !p.expectPeek(token.IDENT) {
		return nil
	}

	stmt.Name = &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}

	if !p.expectPeek(token.ASSIGN) {
		return nil
	}

	// TODO: Skip the expressions until we encounter a semi-colon

	for !p.curTokenIs(token.SEMICOLON) {
		p.nextToken()
	}

	return stmt
}
